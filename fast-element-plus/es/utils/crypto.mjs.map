{"version":3,"file":"crypto.mjs","sources":["../../../packages/utils/crypto.ts"],"sourcesContent":["import { consoleError } from \"@fast-element-plus/utils\";\nimport { AES, enc, mode } from \"crypto-js\";\n\n/**\n * 加密解密\n */\nexport const cryptoUtil = {\n\t/**\n\t * AES\n\t */\n\taes: {\n\t\t/**\n\t\t * AES加密\n\t\t * @param dataStr 要加密的字符串\n\t\t * @param key 用于加密的密钥\n\t\t * @param vector 用于加密的向量（IV）\n\t\t * @param cipherMode 加密模式，默认为CBC模式\n\t\t */\n\t\tencrypt(dataStr: string, key: string, vector: string, cipherMode: any = mode.CBC): string {\n\t\t\tif (!dataStr) {\n\t\t\t\treturn dataStr;\n\t\t\t}\n\n\t\t\t// 处理Key不足32位的问题\n\t\t\tif (key.length < 32) {\n\t\t\t\t// 不足\n\t\t\t\tkey = key.padEnd(32, \"f\");\n\t\t\t}\n\n\t\t\t// 处理Key超过32位的问题\n\t\t\tif (key.length > 32) {\n\t\t\t\t// 超过\n\t\t\t\tkey = key.substring(0, 32);\n\t\t\t}\n\n\t\t\t// 处理IV不足16位的问题\n\t\t\tif (vector.length < 16) {\n\t\t\t\t// 不足\n\t\t\t\tvector = vector.padEnd(16, \"f\");\n\t\t\t}\n\n\t\t\t// 处理IV超过16位的问题\n\t\t\tif (vector.length > 16) {\n\t\t\t\t// 超过\n\t\t\t\tvector = vector.substring(0, 16);\n\t\t\t}\n\n\t\t\treturn AES.encrypt(dataStr, enc.Utf8.parse(key), {\n\t\t\t\tiv: enc.Utf8.parse(vector),\n\t\t\t\tmode: cipherMode,\n\t\t\t}).toString();\n\t\t},\n\t\t/**\n\t\t * AES解密\n\t\t * @param dataStr 要解密的Base64编码字符串\n\t\t * @param key 用于解密的密钥\n\t\t * @param vector 用于解密的向量（IV）\n\t\t * @param cipherMode 解密模式，默认为CBC模式\n\t\t */\n\t\tdecrypt<T = string>(dataStr: string, key: string, vector: string, cipherMode: any = mode.CBC): T | null {\n\t\t\tif (!dataStr) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// 处理Key不足32位的问题\n\t\t\tif (key.length < 32) {\n\t\t\t\t// 不足\n\t\t\t\tkey = key.padEnd(32, \"f\");\n\t\t\t}\n\n\t\t\t// 处理Key超过32位的问题\n\t\t\tif (key.length > 32) {\n\t\t\t\t// 超过\n\t\t\t\tkey = key.substring(0, 32);\n\t\t\t}\n\n\t\t\t// 处理IV不足16位的问题\n\t\t\tif (vector.length < 16) {\n\t\t\t\t// 不足\n\t\t\t\tvector = vector.padEnd(16, \"f\");\n\t\t\t}\n\n\t\t\t// 处理IV超过16位的问题\n\t\t\tif (vector.length > 16) {\n\t\t\t\t// 超过\n\t\t\t\tvector = vector.substring(0, 16);\n\t\t\t}\n\n\t\t\tconst resAESData = AES.decrypt(dataStr, enc.Utf8.parse(key), {\n\t\t\t\tiv: enc.Utf8.parse(vector),\n\t\t\t\tmode: cipherMode,\n\t\t\t});\n\t\t\ttry {\n\t\t\t\tconst result = resAESData.toString(enc.Utf8);\n\t\t\t\treturn JSON.parse(result) as T;\n\t\t\t} catch (error) {\n\t\t\t\tconsoleError(\"AESCrypto\", error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\t},\n};\n"],"names":[],"mappings":";;;AAMO,MAAM,aAAa;AAAA;AAAA;AAAA;AAAA,EAIzB,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQJ,QAAQ,SAAiB,KAAa,QAAgB,aAAkB,KAAK,KAAa;AACzF,UAAI,CAAC,SAAS;AACN,eAAA;AAAA,MACR;AAGI,UAAA,IAAI,SAAS,IAAI;AAEd,cAAA,IAAI,OAAO,IAAI,GAAG;AAAA,MACzB;AAGI,UAAA,IAAI,SAAS,IAAI;AAEd,cAAA,IAAI,UAAU,GAAG,EAAE;AAAA,MAC1B;AAGI,UAAA,OAAO,SAAS,IAAI;AAEd,iBAAA,OAAO,OAAO,IAAI,GAAG;AAAA,MAC/B;AAGI,UAAA,OAAO,SAAS,IAAI;AAEd,iBAAA,OAAO,UAAU,GAAG,EAAE;AAAA,MAChC;AAEA,aAAO,IAAI,QAAQ,SAAS,IAAI,KAAK,MAAM,GAAG,GAAG;AAAA,QAChD,IAAI,IAAI,KAAK,MAAM,MAAM;AAAA,QACzB,MAAM;AAAA,MAAA,CACN,EAAE,SAAS;AAAA,IACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,QAAoB,SAAiB,KAAa,QAAgB,aAAkB,KAAK,KAAe;AACvG,UAAI,CAAC,SAAS;AACN,eAAA;AAAA,MACR;AAGI,UAAA,IAAI,SAAS,IAAI;AAEd,cAAA,IAAI,OAAO,IAAI,GAAG;AAAA,MACzB;AAGI,UAAA,IAAI,SAAS,IAAI;AAEd,cAAA,IAAI,UAAU,GAAG,EAAE;AAAA,MAC1B;AAGI,UAAA,OAAO,SAAS,IAAI;AAEd,iBAAA,OAAO,OAAO,IAAI,GAAG;AAAA,MAC/B;AAGI,UAAA,OAAO,SAAS,IAAI;AAEd,iBAAA,OAAO,UAAU,GAAG,EAAE;AAAA,MAChC;AAEM,YAAA,aAAa,IAAI,QAAQ,SAAS,IAAI,KAAK,MAAM,GAAG,GAAG;AAAA,QAC5D,IAAI,IAAI,KAAK,MAAM,MAAM;AAAA,QACzB,MAAM;AAAA,MAAA,CACN;AACG,UAAA;AACH,cAAM,SAAS,WAAW,SAAS,IAAI,IAAI;AACpC,eAAA,KAAK,MAAM,MAAM;AAAA,eAChB,OAAO;AACf,qBAAa,aAAa,KAAK;AACxB,eAAA;AAAA,MACR;AAAA,IACD;AAAA,EACD;AACD;"}